/** 
  * A list implemented using a sorted doubly-linked list and using recursive methods
  * @author         Amy Takayesu 
  * @class       	ICS311
  * @date           October 17, 2013
  * @source			Edo Biagioni, ICS211 Fall2011
  */

public class DLLDynamicSet<E> {

  // here, include the LinkedNode definition

          /** 
            * A node in a doubly-linked list
            * @author       Amy Takayesu 
            * @class       	ICS311
            * @date         October 17, 2013
            * @source		Edo Biagioni, ICS211 Fall2011
            */
          
          private static class LinkedNode<T> {
            public T item;
            private LinkedNode<T> next;
            private LinkedNode<T> prev;
          
          /** 
            * constructor to build a node with no successor
            * @param the value to be stored by this node
            */
            private LinkedNode(T value) {
              item = value;
              next = null;
              prev = null;
            }
          
          
          /** 
            * constructor to build a node with specified (maybe null) successor and (maybe null) predecessor
            * @param the value to be stored by this node
            * @param the next field for this node
            */
            private LinkedNode(T value, LinkedNode<T> nextnode, LinkedNode<T> prevnode) {
              item = value;
              next = nextnode;
              prev = prevnode;
            }
            
            public Object getItem() {
            	return item;
            }
          }
  // end of the LinkedNode definition


  // this is the start of the linked list.  If the list is empty, it is null
  public LinkedNode<E> head;

  /** 
    * initializes an empty linked list
    */
  public DLLDynamicSet() {
    head = null;
  }

  /** recursive private method, called by the public wrapper method 
    * @param the head of the list (may be null if we are at the end)
    * @return the size of the list
    */
  private int size(LinkedNode<E> current) {
    if (current == null) {
      return 0;  // an empty list has size 0
    }  // a non-empty list has size 1 more than the rest of the list:
    return 1 + size (current.next);
  }
   
  /** public wrapper method, calls the private recursive method 
    * @param none
    * @return the size of the list
    */
  public int size() {
    return size(head);
  }

  
  /** Inserts element e in the set under key k in sorted alphabetical order
   * @param the value to add and the element to set
   */
 public void insert(E value, Object e) {
	 LinkedNode<E> node = head;
	 LinkedNode<E> nodeprev = null;
	 LinkedNode<E> temp;
	 if(node == null) {
		 node = new LinkedNode<E>(value);
		 head = node;
	 }
	 else {
		 while((node != null) && (node.item.toString().compareToIgnoreCase(value.toString()) <= 0)) {
			 nodeprev = node;
			 node = node.next;
		 }
		 if(node == null) {
			 node = new LinkedNode<E>(value, null, nodeprev);
			 nodeprev.next = node;
		 }
		 else {
			 temp = node.prev;
			 node.prev = new LinkedNode<E>(value, node, temp);
			 temp.next = node.prev;
		 }
	 }
 }
 
  /** recursive private method, called by the public wrapper method 
    * @param the head of the list (may be null if we are at the end)
    * @param the value to be added
    * @return the list, with the value added
    */
  private LinkedNode<E> addAtEnd(LinkedNode<E> node, E value) {
    if (node == null) {
      return new LinkedNode<E>(value);
    }
    node.next = addAtEnd(node.next, value);
    return node;
  }
   
  /** public wrapper method, calls the private recursive method 
    * @param the value to be added at the end of the linked list
    */
  public void add(E value) {
    head = addAtEnd(head, value);
  }

  /** recursive private method, called by the public wrapper method 
    * @param the head of the list (may be null if we are at the end)
    * @param the number of nodes to skip before inserting
    * @param the value to be added
    * @return the list, with the value added
    */
  private LinkedNode<E> addAtPosition(LinkedNode<E> node, int skip, E value) {
    if (skip == 0) {
      return new LinkedNode<E>(value, node, null);
    }
    if (node == null) {  // node is null but skip > 0 -- bad index
      throw new IndexOutOfBoundsException("bad index for add");
    }
    node.next = addAtPosition(node.next, skip - 1, value);
    return node;
  }
   
  /** public wrapper method, calls the private recursive method 
    * @param the position at which to add: 0 to add at the start
    * @param the value to be added
    * @throws IndexOutOfBoundsException if the index is less than 0
    *         or greater than the number of elements in the linked list
    */
  public void add(int index, E value) {
    head = addAtPosition(head, index, value);
  }

  /** recursive private method, called by the public wrapper method 
    * @param the head of the list (may be null if we are at the end)
    * @param the value to be removed
    * @return the list, with the value removed
    */
  private LinkedNode<E> delete(LinkedNode<E> node, E value) {
    if (node == null) {  // node is null but skip > 0 -- bad index
      return node;
    }
    if (node.item.equals(value)) {
      return node.next;  // match, so remove this node
    }
    node.next = delete(node.next, value);
    return node;
  }
   
  /** public wrapper method, calls the private recursive method 
    * @param the object to remove
    */
  public void delete(E value) {
    head = delete(head, value);
  }
  
  /** Finds an Object with the key k and returns a pointer to it, or null if not found 
   * @param the key to search for
   */
 public Object search(LinkedNode<E> node, E value) {
   if(node == null){
	   return null;
   }
   String keyCompare = node.item.toString();
   String key = value.toString();
   if(keyCompare.compareToIgnoreCase(key) == 0){
	   return node;
   }
   else if(keyCompare.compareToIgnoreCase(key) > 0) {
	   return search(node.next, value);
   }
   //(keyCompare.compareToIgnoreCase(key) < 0): should never happen
   else {
	   return search(node.prev, value);
   }
   
 }
 
 /** Finds an Object with the key k and returns a pointer to it, or null if not found 
  * @param the key to search for
  */
public Object search(E value) {
	return search(head, value);
}
 
 /** public wrapper method, calls the private recursive method 
  * @param the object to remove
  */
public Object minimum(){
	return (LinkedNode<E>)head;
}

/** public wrapper method, calls the private recursive method 
 * @param the object to remove
 */
public Object maximum() {
	LinkedNode<E> node = head;
	while(node.next != null) {
		node = node.next;
	}
	return (LinkedNode<E>)node;
}

/** public wrapper method, calls the private recursive method 
 * @param the object to remove
 */
public Object successor(E value) {
	LinkedNode<E> node = (LinkedNode<E>)search(head, value);
	return node.next;
}

/** public wrapper method, calls the private recursive method 
 * @param the object to remove
 */
public Object predecessor(E value) {
	LinkedNode<E> node = (LinkedNode<E>)search(head,value);
	return node.prev;
}
 

  /** recursive private method, called by the public wrapper method 
    * @param the head of the list (may be null if we are at the end)
    * @return the string representing the list
    */
  private String toString(LinkedNode<E> node) {
    if (node == null) {
      return "";
    }
    if (node.next == null) {
      return node.item.toString();
    }
    return node.item.toString() + " ==> " + toString(node.next);
  }

  /** 
    * concatenates the elements of the linked list, separated by " ==> "
    * @return the string representation of the list
    */
  public String toString() {
    return toString(head);
  }

  /** 
    * Takes in command line arguments to create a list of the strings, with the first string repeating in the list
    * @param String [] arguments
    */
  public static void main (String [] arguments) {
	  DLLDynamicSet list = new DLLDynamicSet();
	  list.insert("Apple", null);
	  list.insert("Mushroom", null);
	  list.insert("Bacon", null);
	  list.insert("Tomato", null);
	  list.insert("Macaroon", null);
	  list.insert("Xray", null);
	  System.out.println(list.toString());
	  System.out.println("Size: "+ list.size());
	  list.delete("Tomato");
	  System.out.println("Deleted tomato: " + list.toString());
	  System.out.println("Found Bacon? " + list.search("Bacon"));
	  System.out.println("Minimum " + (list.minimum()).getItem());
	  System.out.println("Maximum " + list.maximum().getItem());
	  System.out.println("Successor of tomato " + list.successor("Macaroon"));
	  System.out.println("Predecessor of tomato " + list.predecessor("Macaroon"));
  }
}
